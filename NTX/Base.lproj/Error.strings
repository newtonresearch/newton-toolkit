
/* Store and soup errors */
"-48001" = "CStore is not a frame store";
"-48002" = "Store format is too old to understand";
"-48003" = "Store format is too new to understand";
"-48004" = "Store is corrupted, can't recover";
"-48005" = "Single object is corrupted, can't recover";
"-48006" = "Object stream has unknown format version";
"-48007" = "Fault block is invalid (probably from a removed store)";
"-48008" = "Not a fault block (internal error)";
"-48009" = "Not a soup entry";
"-48010" = "Tried to remove a store that wasn't registered";
"-48011" = "Soup index has an unknown type";
"-48012" = "Soup index has an unknown key structure";
"-48013" = "Soup index does not exist";
"-48014" = "A soup with this name already exists";
"-48015" = "Tried to CopyEntries to a union soup";
"-48016" = "Soup is invalid (probably from a removed store)";
"-48017" = "Soup is invalid (probably from a removed store)";
"-48018" = "Entry is invalid (probably from a removed store)";
"-48019" = "Key does not have the type specified in the index";
"-48020" = "Store is in ROM";
"-48021" = "Soup already has an index with this path";
"-48022" = "Internal error--something unexpected happened";
"-48023" = "Tried to RemoveIndex the _uniqueId index";
"-48024" = "Query type missing or unknown";
"-48025" = "Discovered index inconsistency";

/* Object system errors */
"-48200" = "Expected an array, frame, or binary object, got %value.";
"-48201" = "Bad magic pointer: @%value.";
"-48202" = "Empty path";
"-48203" = "Invalid segment %value. in path expression";
"-48204" = "Path %value. failed";
"-48205" = "Index %index. out of bounds for object %value.";
"-48206" = "Source and dest must be different objects: both were %value.";
"-48207" = "Long out of range";
"-48208" = "Call SetObjectHeapSize only once, before InitObjects";
"-48209" = "GC during GC";
"-48210" = "Bad arguments";
"-48211" = "String too big";
"-48212" = "Unexpected nil";
"-48213" = "internal error - unassigned CFramesObjectPtr";
"-48214" = "Object %value. is read-only";
"-48215" = "Functionality is unimplemented";
"-48216" = "Ran out of heap memory";
"-48217" = "Attempted use of magic pointer: @%value. (not allowed in this application)";

/* Bad type errors */
"-48400" = "Expected a frame, got %value.";
"-48401" = "Expected an array, got %value.";
"-48402" = "Expected a string, got %value.";
"-48403" = "Expected an array, frame, or binary object, got %value.";
"-48404" = "Expected a number, got %value.";
"-48405" = "Expected a real, got %value.";
"-48406" = "Expected an integer, got %value.";
"-48407" = "Expected a character, got %value.";
"-48408" = "Expected a binary object, got %value.";
"-48409" = "Expected a path expression (or a symbol or int), got %value.";
"-48410" = "Expected a symbol, got %value.";
"-48411" = "Expected a function, got %value.";
"-48412" = "Expected a frame or an array, got %value.";
"-48413" = "Expected an array or nil, got %value.";
"-48414" = "Expected a string or nil, got %value.";
"-48415" = "Expected a binary object or nil, got %value.";
"-48416" = "Unexpected frame %value.";
"-48417" = "Unexpected binary object %value.";
"-48418" = "Unexpected immediate %value.";

/* Compiler errors */
"-48600" = "Couldn't open listener window";
"-48601" = "%value.";
"-48602" = "Couldn't open bytecode dump file";
"-48603" = "Assignment to constant %value.";
"-48604" = "Can't test for subscript existence -- use length";
"-48605" = "Global variable %value. in application";
"-48606" = "Global variable and global constant both have name %value.";
"-48607" = "Redefinition of constant %value.";
"-48608" = "Variable and constant both have name %value. in the same scope";
"-48609" = "Non-literal expression for constant initializer";
"-48610" = "End of file inside a string";
"-48611" = "Odd number of digits between \\us";
"-48612" = "No escapes but \\u are allowed after \\u";
"-48613" = "Invalid hex character in \\u string";
"-48614" = "# must be followed by a hex number or \"line\"";
"-48615" = "Bad #line number";
"-48616" = "Bad #line filename";
"-48617" = "Two-digit hex number required after $\\";
"-48618" = "Four-digit hex number required after $\\u";
"-48619" = "Illegal character %value.";
"-48620" = "Invalid hexadecimal integer: %value. (out of range)";
"-48621" = "Invalid real number: %value. (out of range)";
"-48622" = "Invalid decimal integer: %value. (out of range)";
"-48623" = "WalkForPath: invalid argument";
"-48624" = "# parser got confused";
"-48625" = "CCompiler::getNumber - internal error: buf overflow";
"-48626" = "#nnnnnnn not allowed in Newton ToolKit";

/* Interpreter errors */
"-48800" = "Not in a break loop";
"-48801" = "Function not available in Fram";
"-48802" = "Too many args for a CFunction";
"-48803" = "Wrong number of args";
"-48804" = "For loop by expression has value zero";
"-48805" = "Bad bytecode";
"-48806" = "No current exception";
"-48807" = "Undefined variable: %value.";
"-48808" = "Undefined global function: %value.";
"-48809" = "Undefined method: %value.";
"-48810" = "No _proto for inherited send: %value.";
"-48811" = "Tried to access slot in nil context: %value.";
"-48812" = "Interpreter stack underflow";
"-48813" = "PeekN - out of range";
"-48814" = "Local variables and FOR/FOREACH loops not allowed at top level";

/* Package errors */
"-10401" = "Bad package.";
"-10402" = "Package already exists.";
"-10403" = "Bad package version number.";
"-10404" = "Unexpected end of package part.";
"-10405" = "Unexpected end of package.";
"-10406" = "Part type already register.";
"-10407" = "Part type not registered.";
"-10408" = "No such package.";
"-10409" = "A newer package already exists.";
"-10410" = "An older package already exists.";

/* OS errors */
"-10021" = "Message timed out.";
